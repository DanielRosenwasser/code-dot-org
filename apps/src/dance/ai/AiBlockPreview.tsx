import {BlockSvg, Workspace, WorkspaceSvg} from 'blockly';
import React, {useEffect, useRef} from 'react';
import moduleStyles from './ai-block-preview.module.scss';
import {GeneratedEffect} from './types';
import {useSelector} from 'react-redux';

interface AiBlockPreviewProps {
  results: GeneratedEffect;
}

/**
 * Previews the blocks generated by the AI block in Dance Party.
 */
const AiBlockPreview: React.FunctionComponent<AiBlockPreviewProps> = ({
  results,
}) => {
  const blockPreviewContainerRef = useRef<HTMLSpanElement>(null);
  const workspaceRef = useRef<Workspace | null>(null);
  const isRtl = useSelector((state: {isRtl: boolean}) => state.isRtl);

  // Create the workspace once the container has been rendered.
  useEffect(() => {
    if (!blockPreviewContainerRef.current) {
      return;
    }

    const xml = `
      <xml>
        <block type="Dancelab_setForegroundEffectExtended" x="20" y="0">
          <field name="EFFECT">"${results.foregroundEffect}"</field>
          <next>
            <block type="Dancelab_setBackgroundEffectWithPaletteAI">
              <field name="PALETTE">"${results.backgroundColor}"</field>
              <field name="EFFECT">"${results.backgroundEffect}"</field>
            </block>
          </next>
        </block>
      </xml>
      `;

    const blocks = Blockly.utils.xml.textToDom(xml);
    workspaceRef.current = Blockly.BlockSpace.createReadOnlyBlockSpace(
      blockPreviewContainerRef.current,
      blocks,
      {rtl: isRtl}
    );
  }, [blockPreviewContainerRef, isRtl, results]);

  // Dispose of the workspace on unmount.
  useEffect(() => () => workspaceRef.current?.dispose(), []);

  return (
    <span ref={blockPreviewContainerRef} className={moduleStyles.container} />
  );
};

export default AiBlockPreview;
